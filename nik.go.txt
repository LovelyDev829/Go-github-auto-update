package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"
)

const (
	repoPath    = "../nik-hello-world/"     // Modify this path to the location of your local repo
	execCommand = repoPath + "hello-world" // Command to run after git pull
)

const (
	Reset  = "\033[0m"
	Green  = "\033[32m"
	Red    = "\033[31m"
	Yellow = "\033[33m"
)

var failedCommit string // Store the hash of the last failed commit

type Repository struct {
	DefaultBranch string `json:"default_branch"`
}

type Comparison struct {
	AheadBy int `json:"ahead_by"`
	BehindBy int `json:"behind_by"`
}

func main() {
	ticker := time.NewTicker(2 * time.Second) // Check for updates once every 2 seconds
	defer ticker.Stop()

	for range ticker.C {
		// Print current time
		fmt.Printf("%s----------------------------------------------------------------%s\n", Green, Reset)
		fmt.Printf("%sChecking Updates on Github at: %s%s\n", Green, time.Now().Format(time.RFC3339), Reset)

		// Check for changes in the repository
		changed, comparison, err := hasChanges("LovelyDev829", "nik-hello-world", "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", "main", "origin/main")
		if err != nil {
			fmt.Printf("%sError checking repository for changes: %s%s\n", Red, err, Reset)
			continue
		}

		if changed {
			fmt.Printf("%sChanges in the repository:%s\n", Yellow, Reset)
			fmt.Printf("Ahead By: %d, Behind By: %d\n", comparison.AheadBy, comparison.BehindBy)

			err := gitPull(repoPath)
			if err != nil {
				fmt.Printf("%sError updating repository: %s%s\n", Red, err, Reset)
			} else {
				fmt.Printf("%sRepository updated successfully: %s\n", Yellow, Reset)

				// Run the command after git pull
				err := runCommand(execCommand)
				if err != nil {
					fmt.Printf("%sError running command: %s%s\n", Red, err, Reset)

					// Remember the failed commit
					failedCommit = getCurrentCommit(repoPath)
				} else {
					fmt.Printf("%sCommand executed successfully. %s\n", Yellow, Reset)
				}
			}
		} else {
			fmt.Println("No changes in the repository or the branch is up to date.")

			// If the failed commit is detected as a change, skip pulling
			if failedCommit != "" {
				currentCommit := getCurrentCommit(repoPath)
				if currentCommit == failedCommit {
					fmt.Printf("%sSkipping pull as the failed commit is detected as a change.%s\n", Yellow, Reset)
					continue
				}
			}
		}
	}
}

func hasChanges(owner, repo, token, localBranch, remoteBranch string) (bool, *Comparison, error) {
	comparison, err := compareBranches(owner, repo, localBranch, remoteBranch, token)
	if err != nil {
		return false, nil, err
	}
	return comparison.BehindBy > 0 || comparison.AheadBy > 0, comparison, nil
}

func compareBranches(owner, repo, localBranch, remoteBranch, token string) (*Comparison, error) {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/compare/%s...%s", owner, repo, localBranch, remoteBranch)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Authorization", "token "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var comparison Comparison
	err = json.NewDecoder(resp.Body).Decode(&comparison)
	if err != nil {
		return nil, err
	}

	return &comparison, nil
}

func gitPull(repoDir string) error {
	cmd := exec.Command("git", "pull")
	cmd.Dir = repoDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func runCommand(command string) error {
	cmd := exec.Command(command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func getCurrentCommit(repoDir string) string {
	cmd := exec.Command("git", "rev-parse", "HEAD")
	cmd.Dir = repoDir
	output, err := cmd.Output()
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(output))
}
